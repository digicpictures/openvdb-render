uniform vec3 view_dir_world : ViewDirection;
uniform vec3 view_dir_model;
uniform vec3 view_pos_world;
uniform mat4 world_mat : World;
uniform mat4 world_inverse_mat : WorldInverse;
uniform mat4 world_view_proj_mat : WorldViewProjection;

uniform vec3 volume_size;    // in model space.
uniform vec3 volume_origin;  // in model space.

uniform int max_slice_count;
uniform int dominant_axis; // 0: x, 1: y, 2:z


// ======== VERTEX SHADER ========

attribute VERT_INPUT
{
    vec3 in_pos : POSITION;
};

attribute VERT_OUTPUT
{
    vec3 pos_model;
    vec3 pos_world;
};

GLSLShader VolumeVertexShader {

int GetDominantAxis()
{
#ifdef DEBUG
    return (force_axis == -1) ? dominant_axis : force_axis;
#else
    return dominant_axis;
#endif
}

vec3 Swizzle(vec3 v, int i)
{
    if (i == 1)
        return v.zxy;
    else if (i == 2)
        return v.yzx;
    else
        return v;
}

float GetComponent(vec3 v, int i)
{
    if (i == 1)
        return v.y;
    else if (i == 2)
        return v.z;
    else
        return v.x;
}

void main()
{
    int dom_ax = GetDominantAxis();

    vec2 pos_slice = in_pos.xy;
    int slice_idx = int(round(in_pos.z));

    // Ensure back-to-front render order.
    if (GetComponent(view_dir_model, dom_ax) > 0) {
        slice_idx = max_slice_count - 1 - slice_idx;
        pos_slice.x = 1 - pos_slice.x; // for correct winding order.
    }
    vec3 pos_dom = vec3(float(slice_idx) / (max_slice_count - 1), pos_slice);
    vec3 pos_model = Swizzle(pos_dom, dom_ax) * volume_size + volume_origin;
    vec3 pos_world = (world_mat * vec4(pos_model, 1)).xyz;
    vec4 pos_clip = world_view_proj_mat * vec4(pos_model, 1);

    output.pos_model = pos_model;
    output.pos_world = pos_world;
    gl_Position = pos_clip;
}

}


// ======== FRAGMENT SHADER ======

// Channels.

#define DENSITY_SOURCE_VALUE 0
#define DENSITY_SOURCE_RAMP  1

uniform float     density = 1.0f;
uniform int       density_source = DENSITY_SOURCE_VALUE;
uniform bool      use_density_texture = true;
uniform vec2      density_value_range;
uniform vec3      density_volume_size;
uniform vec3      density_volume_origin;
uniform texture3D density_texture;
uniform sampler3D density_sampler = sampler_state {
    Texture = <density_texture>;
};

#define COLOR_SOURCE_COLOR 0
#define COLOR_SOURCE_RAMP  1

uniform float     scattering_intensity = 1;
uniform vec3      scattering_color;
uniform int       scattering_color_source = COLOR_SOURCE_COLOR;
uniform float     scattering_anisotropy = 0;
uniform bool      use_scattering_texture = true;
uniform vec2      scattering_value_range;
uniform vec3      scattering_volume_size;
uniform vec3      scattering_volume_origin;
uniform texture3D scattering_texture;
uniform sampler3D scattering_sampler = sampler_state {
    Texture = <scattering_texture>;
};

uniform vec3      transparency;
uniform bool      use_transparency_texture = true;
uniform vec2      transparency_value_range;
uniform vec3      transparency_volume_size;
uniform vec3      transparency_volume_origin;
uniform texture3D transparency_texture;
uniform sampler3D transparency_sampler = sampler_state {
    Texture = <transparency_texture>;
};

#define EMISSION_MODE_NONE                  0
#define EMISSION_MODE_DENSITY               1
#define EMISSION_MODE_CHANNEL               2
#define EMISSION_MODE_BLACKBODY             3
#define EMISSION_MODE_DENSITY_AND_BLACKBODY 4
uniform int       emission_mode = 0;
uniform int       emission_color_source = COLOR_SOURCE_COLOR;
uniform bool      use_emission_texture = false;
uniform float     emission_intensity = 1;
uniform vec3      emission_color;
uniform vec2      emission_value_range;
uniform vec3      emission_volume_size;
uniform vec3      emission_volume_origin;
uniform texture3D emission_texture;
uniform sampler3D emission_sampler = sampler_state {
    Texture = <emission_texture>;
};

uniform float     temperature = 5000.0f;
uniform bool      use_temperature_texture = false;
uniform vec2      temperature_value_range;
uniform vec3      temperature_volume_size;
uniform vec3      temperature_volume_origin;
uniform texture3D temperature_texture;
uniform sampler3D temperature_sampler = sampler_state {
    Texture = <temperature_texture>;
};

uniform float     blackbody_intensity = 1.0f;
uniform texture1D blackbody_lut_texture;
uniform sampler1D blackbody_lut_sampler = sampler_state {
    Texture = <blackbody_lut_texture>;
};

// Ramps.

uniform vec2      density_ramp_domain;
uniform texture1D density_ramp_texture;
uniform sampler1D density_ramp_sampler = sampler_state {
    Texture = <density_ramp_texture>;
};

uniform vec2      scattering_ramp_domain;
uniform texture1D scattering_ramp_texture;
uniform sampler1D scattering_ramp_sampler = sampler_state {
    Texture = <scattering_ramp_texture>;
};

uniform vec2      emission_ramp_domain;
uniform texture1D emission_ramp_texture;
uniform sampler1D emission_ramp_sampler = sampler_state {
    Texture = <emission_ramp_texture>;
};

// Lights and shadows.

#define LIGHT_FLAG_POINT_LIGHT       0
#define LIGHT_FLAG_DIRECTIONAL_LIGHT 1
#define LIGHT_FLAG_SPOTLIGHT         2
#define LIGHT_FLAG_MASK_TYPE         3
#define LIGHT_FLAG_CAST_SHADOWS      8

uniform int    light_count;
uniform int    light_flags[MAX_LIGHT_COUNT];
uniform vec3   light_position[MAX_LIGHT_COUNT];
uniform vec3   light_direction[MAX_LIGHT_COUNT];
uniform vec3   light_color[MAX_LIGHT_COUNT];
uniform float  light_intensity[MAX_LIGHT_COUNT];
uniform float  light_decay_exponent[MAX_LIGHT_COUNT];
uniform vec3   light_shadow_color[MAX_LIGHT_COUNT];
uniform float  light_cutoff_costheta1[MAX_LIGHT_COUNT];
uniform float  light_cutoff_costheta2[MAX_LIGHT_COUNT];
uniform float  light_dropoff[MAX_LIGHT_COUNT];

uniform float shadow_gain = 0.2;
uniform int shadow_sample_count = 4;


#define DEBUG_COLOR vec3(1.0, 0.5, 0.5)
#define DEBUG_COLOR4 vec4(1.0, 0.5, 0.5, 1)

#define EPS 1e-7f
#define EPS3 vec3(EPS, EPS, EPS)

#define FRAG_INPUT VERT_OUTPUT

attribute FRAG_OUTPUT
{
    vec4 out_color : COLOR0;
};

GLSLShader VolumeFragmentShader {

int GetDominantAxis()
{
#ifdef DEBUG
    return (force_axis == -1) ? dominant_axis : force_axis;
#else
    return dominant_axis;
#endif
}

vec3 Swizzle(vec3 v, int i)
{
    if (i == 1)
        return v.zxy;
    else if (i == 2)
        return v.yzx;
    else
        return v;
}

float GetComponent(vec3 v, int i)
{
    if (i == 1)
        return v.y;
    else if (i == 2)
        return v.z;
    else
        return v.x;
}

float unlerp(float a, float b, float x)
{
    return (x - a) / (b - a);
}

float MaxComponent(vec3 v)
{
    return max(max(v.x, v.y), v.z);
}

float MinComponent(vec3 v)
{
    return min(min(v.x, v.y), v.z);
}

vec3 LinearFromSRGB(vec3 color)
{
    return pow(color, vec3(2.2f, 2.2f, 2.2f));
}

vec3 SRGBFromLinear(vec3 color)
{
    return pow(color, vec3(1.0f/2.2f, 1.0f/2.2f, 1.0f/2.2f));
}

vec4 SampleTexture1D(sampler1D sampler, float tex_coord, float lod)
{
    return textureLod(sampler, tex_coord, lod);
}

vec4 SampleTexture3D(sampler3D sampler, vec3 tex_coords, float lod)
{
    return textureLod(sampler, tex_coords, lod);
}

float SampleFloatRamp(sampler1D ramp_sampler, float texcoord)
{
    return SampleTexture1D(ramp_sampler, texcoord, 0).x;
}

vec3 SampleColorRamp(sampler1D ramp_sampler, float texcoord)
{
    return LinearFromSRGB(texture(ramp_sampler, texcoord).xyz);
}

#define SQR(x) ((x) * (x))
#define PI 3.14159265f
float BlackbodyRadiance(float temperature)
{
    const float sigma = 5.670367e-8f; // Stefan-Boltzmann constant
    float power = sigma * SQR(SQR(temperature));

    // non-physically correct control to reduce the intensity
    if (blackbody_intensity < 1.0f)
       power = lerp(sigma, power, max(blackbody_intensity, 0.0f));

    // convert power to spectral radiance
    return power * (1e-6f / PI);
}

vec3 BlackbodyColor(float temperature)
{
    float texcoord = (temperature - BLACKBODY_LUT_MIN_TEMP) / (BLACKBODY_LUT_MAX_TEMP - BLACKBODY_LUT_MIN_TEMP);
    return SampleColorRamp(blackbody_lut_sampler, texcoord) * BLACKBODY_LUT_NORMALIZER;
}

float CalcLOD(float distance_model, vec3 size_model)
{
    vec3 distance_voxels = (distance_model / size_model) * float(max_slice_count - 1);
    float max_component = MaxComponent(distance_voxels) + EPS;
    return clamp(log(max_component) / log(2.f), 0.f, 16.f);
}

float SampleDensityTexture(vec3 pos_model, float lod_scale_model)
{
    if (use_density_texture)
    {
        vec3 tex_coords = (pos_model - density_volume_origin) / density_volume_size;
        float lod = CalcLOD(lod_scale_model, density_volume_size);
        float tex_sample = SampleTexture3D(density_sampler, tex_coords, lod).r;
        float channel_value = lerp(density_value_range.x, density_value_range.y, tex_sample);
        if (density_source == DENSITY_SOURCE_RAMP)
            channel_value *= SampleFloatRamp(density_ramp_sampler, unlerp(density_ramp_domain.x, density_ramp_domain.y, channel_value));
        return density * channel_value;
    }
    else
        return density;
}

vec3 SampleScatteringTexture(vec3 pos_model, float lod_scale_model)
{
    float channel_value = 0;
    if (use_scattering_texture)
    {
        vec3 tex_coords = (pos_model - scattering_volume_origin) / scattering_volume_size;
        float lod = CalcLOD(lod_scale_model, scattering_volume_size);
        float voxel_value = SampleTexture3D(scattering_sampler, tex_coords, lod).r;
        channel_value = lerp(scattering_value_range.x, scattering_value_range.y, voxel_value);
    }

    vec3 res = scattering_color;
    if (scattering_color_source == COLOR_SOURCE_RAMP)
        res = SampleColorRamp(scattering_ramp_sampler, unlerp(scattering_ramp_domain.x, scattering_ramp_domain.y, channel_value));
    res *= scattering_intensity;

    if (use_scattering_texture)
        res *= channel_value;

    return res;
}

vec3 SampleTransparencyTexture(vec3 pos_model, float lod_scale_model)
{
    vec3 res = transparency;
    if (use_transparency_texture)
    {
        vec3 tex_coords = (pos_model - transparency_volume_origin) / transparency_volume_size;
        float lod = CalcLOD(lod_scale_model, transparency_volume_size);
        float voxel_value = SampleTexture3D(transparency_sampler, tex_coords, lod).r;
        res *= lerp(transparency_value_range.x, transparency_value_range.y, voxel_value);
    }

    return clamp(res, vec3(EPS, EPS, EPS), vec3(1, 1, 1));
}

float SampleTemperatureTexture(vec3 pos_model, float lod_scale_model)
{
    float res = temperature;
    if (use_temperature_texture)
    {
        vec3 tex_coords = (pos_model - temperature_volume_origin) / temperature_volume_size;
        float lod = CalcLOD(lod_scale_model, temperature_volume_size);
        float voxel_value = SampleTexture3D(temperature_sampler, tex_coords, lod).r;
        res *= lerp(temperature_value_range.x, temperature_value_range.y, voxel_value);
    }

    return res;
}

vec3 SampleEmissionTexture(vec3 pos_model, float lod_scale_model)
{
    if (emission_mode == EMISSION_MODE_NONE)
        return vec3(0, 0, 0);

    float channel_value = 0;
    if (use_emission_texture)
    {
        vec3 tex_coords = (pos_model - emission_volume_origin) / emission_volume_size;
        float lod = CalcLOD(lod_scale_model, emission_volume_size);
        float voxel_value = SampleTexture3D(emission_sampler, tex_coords, lod).r;
        channel_value = lerp(emission_value_range.x, emission_value_range.y, voxel_value);
    }

    vec3 res = emission_color;
    if (emission_color_source == COLOR_SOURCE_RAMP)
        res = SampleColorRamp(emission_ramp_sampler, unlerp(emission_ramp_domain.x, emission_ramp_domain.y, channel_value));
    res *= emission_intensity;

    if (use_emission_texture)
        res *= channel_value;

    res = max(vec3(0, 0, 0), res);

    if (emission_mode == EMISSION_MODE_BLACKBODY || emission_mode == EMISSION_MODE_DENSITY_AND_BLACKBODY)
    {
        if (!use_temperature_texture)
            return vec3(0, 0, 0);

        float temperature = SampleTemperatureTexture(pos_model, lod_scale_model);
        if (temperature <= 0)
            return vec3(0, 0, 0);

        vec3 blackbody = BlackbodyColor(temperature) * BlackbodyRadiance(temperature);
        res *= blackbody;
    }

    return res;
}

#define ONE_OVER_4PI 0.07957747f
float HGPhase(float costheta)
{
    float g = scattering_anisotropy;
    float g_squared = g * g;
    return ONE_OVER_4PI * (1 - g_squared) / pow(1 + g_squared - 2*g*costheta, 1.5f);
}

vec3 RayTransmittance(vec3 from_world, vec3 to_world)
{
    vec3 step_world = (to_world - from_world) / float(shadow_sample_count + 1);
    float  step_size_world = length(step_world);
    vec3 step_model = (world_inverse_mat * vec4(step_world, 0)).xyz;
    float  step_size_model = length(step_model);

    vec3 from_model = (world_inverse_mat * vec4(from_world, 1)).xyz;

    vec3 transmittance = vec3(1, 1, 1);
    vec3 pos_model = from_model + 0.5f * step_model;
    for (int i = 0; i < shadow_sample_count; ++i) {
        float density = SampleDensityTexture(pos_model, step_size_model);
        vec3 transparency = SampleTransparencyTexture(pos_model, step_size_model);
        if (density >= EPS) {
            float exponent = density * step_size_world / (1.0 + float(i) * step_size_world * shadow_gain);
            transmittance *= pow(transparency, vec3(exponent, exponent, exponent));
        }
        pos_model += step_model;
    }
    return transmittance;
}

vec3 StretchToVolumeSize(vec3 dir_world)
{
    vec3 dir_model = normalize((world_inverse_mat * vec4(dir_world, 0)).xyz);
    float len = MinComponent(abs(volume_size / dir_model));
    return (world_mat * vec4(len * dir_model, 0)).xyz;
}

int LightType(int light_index)
{
    return light_flags[light_index] & LIGHT_FLAG_MASK_TYPE;
}

vec3 ShadowFactor(int light_index, vec3 shadow_ray_begin, vec3 shadow_ray_end)
{
    vec3 transmittance = RayTransmittance(shadow_ray_begin, shadow_ray_end);
    return (vec3(1, 1, 1) - transmittance) * (vec3(1, 1, 1) - light_shadow_color[light_index]);
}

vec3 LightLuminanceDirectional(int light_index, vec3 pos_world, vec3 direction_to_eye_world, vec3 albedo)
{
    // Light luminance at source.
    vec3 lumi = light_color[light_index] * light_intensity[light_index];

    // Albedo.
    lumi *= albedo;

    // Phase.
    vec3 direction_to_light = -light_direction[light_index];
    float phase = HGPhase(dot(direction_to_eye_world, direction_to_light));
    lumi *= phase;

    // Bail if light casts no shadows or shadowing practically wouldn't affect the outcome.
    if ((light_flags[light_index] & LIGHT_FLAG_CAST_SHADOWS) == 0)
        return lumi;

    // Shadow.
    vec3 shadow_vector = 0.5f * StretchToVolumeSize(direction_to_light);
    lumi *= (vec3(1, 1, 1) - ShadowFactor(light_index, pos_world, pos_world + shadow_vector));

    return lumi;
}

vec3 LightLuminancePointSpot(int light_index, vec3 pos_world, vec3 direction_to_eye_world, vec3 albedo)
{
    // Light luminance at source.
    vec3 lumi = light_color[light_index] * light_intensity[light_index];

    // Albedo.
    lumi *= albedo;

    // Phase.
    vec3 vector_to_light_world = light_position[light_index] - pos_world;
    float  distance_to_light_world = max(length(vector_to_light_world), EPS);
    vec3 direction_to_light_world = vector_to_light_world / distance_to_light_world;
    float phase = HGPhase(dot(direction_to_eye_world, direction_to_light_world));
    lumi *= phase;

    // Decay.
    lumi *= pow(distance_to_light_world, -light_decay_exponent[light_index]);

    // Angular shadowing for spot lights.
    if (LightType(light_index) == LIGHT_FLAG_SPOTLIGHT)
    {
        float costheta = dot(light_direction[light_index], -direction_to_light_world);

        // Cone.
        float cutoff1 = light_cutoff_costheta1[light_index];
        float cutoff2 = light_cutoff_costheta2[light_index];
        if (costheta < cutoff2)
            return vec3(0, 0, 0);
        else if (costheta < cutoff1)
            lumi *= (cutoff2 - costheta) / (cutoff2 - cutoff1);

        // Dropoff.
        lumi *= pow(costheta, light_dropoff[light_index]);
    }

    // Bail if light casts no shadows or shadowing practically wouldn't affect the outcome.
    if ((light_flags[light_index] & LIGHT_FLAG_CAST_SHADOWS) == 0)
        return lumi;

    // Shadow.
    vec3 shadow_vector = vector_to_light_world;
    float  max_distance_world = length(StretchToVolumeSize(vector_to_light_world));
    if (distance_to_light_world > max_distance_world)
        shadow_vector = direction_to_light_world * max_distance_world;
    lumi *= (vec3(1, 1, 1) - ShadowFactor(light_index, pos_world, pos_world + shadow_vector));

    return lumi;
}

vec3 LightLuminance(int light_index, vec3 pos_world, vec3 direction_to_eye_world, vec3 albedo)
{
    int type = LightType(light_index);
    if (type == LIGHT_FLAG_POINT_LIGHT || type == LIGHT_FLAG_SPOTLIGHT)
        return LightLuminancePointSpot(light_index, pos_world, direction_to_eye_world, albedo);
    else if (type == LIGHT_FLAG_DIRECTIONAL_LIGHT)
        return LightLuminanceDirectional(light_index, pos_world, direction_to_eye_world, albedo);
    else
        return DEBUG_COLOR; // Unsupported light.
}

void main()
{
    int dom_ax = GetDominantAxis();
    float density = SampleDensityTexture(input.pos_model, 0);
    vec3 transparency = SampleTransparencyTexture(input.pos_model, 0);
    vec3 albedo = SampleScatteringTexture(input.pos_model, 0);
    // Note: albedo is scattering / extinction. Intuitively light lumi should
    //       be multiplied by scattering, but because
    //         integral(exp(a*t)dt) = 1/a exp(a*t),
    //       and light contribution from in-scattering is
    //         integral_0^t(exp(-extinciton*t)*phase*light_radiance dt)
    //       evaluating the integral will yeild a 1/extinction factor, assuming
    //       piecewise constant phase and light radiance.

    vec3 direction_to_eye_world = normalize(view_pos_world - input.pos_world);

    vec3 slice_vector_model = Swizzle(vec3(1, 0, 0), dom_ax) * volume_size / float(max_slice_count - 1);
    vec3 slice_vector_world = (world_mat * vec4(slice_vector_model, 0)).xyz; //world_mat_3x3 * slice_vector_model;
    float ray_distance = dot(slice_vector_world, slice_vector_world) / abs(dot(slice_vector_world, direction_to_eye_world));

    vec3 lumi = vec3(0, 0, 0);

    // In-scattering from lights.

    for (int i = 0; i < light_count; ++i)
        lumi += LightLuminance(i, input.pos_world, direction_to_eye_world, albedo);

    // Premultiply alpha.
    float exponent = density * ray_distance;
    vec3 transmittance = pow(transparency, vec3(exponent, exponent, exponent));
    float alpha = 1 - dot(transmittance, vec3(1, 1, 1) / 3);
    lumi *= alpha;

    // Emission.

    vec3 emission = SampleEmissionTexture(input.pos_model, 0);
    if (emission_mode == EMISSION_MODE_DENSITY || emission_mode == EMISSION_MODE_DENSITY_AND_BLACKBODY)
        emission *= density;

    vec3 extinction = density * -log(transparency);
    vec3 x = -ray_distance * extinction;
    // Truncated series of (1 - exp(-dt)) / t; d = ray_distance, t = extinction.
    vec3 emission_factor = ray_distance * (1 - x * (0.5f + x * (1.0f/6.0f - x / 24.0f)));
    emission *= emission_factor;
    lumi += emission;

    out_color = vec4(lumi, alpha);

    if (isnan(out_color.x) || isnan(out_color.y) ||
        isnan(out_color.z) || isnan(out_color.w))
        out_color = DEBUG_COLOR4;
}
}

technique Main < string Transparency = "Transparent"; int isTransparent = 1; string OverridesDrawState = "true"; >
{
    pass P0
    {
        VertexShader (in VERT_INPUT, out VERT_OUTPUT output) = VolumeVertexShader;
        PixelShader (in FRAG_INPUT input, out FRAG_OUTPUT) = VolumeFragmentShader;
    }
}

